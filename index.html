<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Figure 7 – Realistic Optimized Microgrid Layout</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95) 0%, rgba(32, 58, 67, 0.9) 100%);
            color: white;
            padding: 25px;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            max-width: 350px;
            transition: all 0.3s ease;
        }
        
        .ui-overlay:hover {
            transform: translateY(-2px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }
        
        .title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 2px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 8px;
        }
        
        .subtitle {
            font-size: 13px;
            color: #b0bec5;
            margin-bottom: 20px;
            font-style: italic;
            font-weight: 300;
        }
        
        .stats {
            font-size: 12px;
            line-height: 1.5;
        }
        
        .stat-item {
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .stat-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(4px);
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
            font-size: 13px;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95) 0%, rgba(32, 58, 67, 0.9) 100%);
            color: white;
            padding: 20px;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }
        
        .control-button {
            background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 6px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(66, 165, 245, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-button:hover {
            background: linear-gradient(135deg, #1e88e5 0%, #1565c0 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(66, 165, 245, 0.4);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 200;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #42a5f5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95) 0%, rgba(32, 58, 67, 0.9) 100%);
            color: white;
            padding: 20px;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            max-width: 280px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(4px);
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .performance-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(15, 32, 39, 0.95) 0%, rgba(32, 58, 67, 0.9) 100%);
            color: white;
            padding: 15px;
            border-radius: 16px;
            z-index: 100;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            font-size: 11px;
        }
        
        .fps-counter {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .energy-flow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 20px;
            background: linear-gradient(0deg, transparent, #4fc3f7, transparent);
            border-radius: 2px;
            animation: energyFlow 1.5s ease-in-out infinite;
        }
        
        @keyframes energyFlow {
            0% { transform: translateY(-10px) scale(1, 0); opacity: 0; }
            50% { transform: translateY(0) scale(1, 1); opacity: 1; }
            100% { transform: translateY(10px) scale(1, 0); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">
            <div>Loading Advanced 3D Microgrid...</div>
            <div class="loading-spinner"></div>
        </div>
        
        <div class="ui-overlay">
            <div class="title">Figure 7 – Optimized Microgrid Layout</div>
            <div class="subtitle">AI-optimized renewable energy distribution system</div>
            <div class="stats">
                <div class="stat-item">
                    <span>Solar Panels:</span>
                    <span class="stat-value">8 units</span>
                </div>
                <div class="stat-item">
                    <span>Battery Storage:</span>
                    <span class="stat-value">3 units</span>
                </div>
                <div class="stat-item">
                    <span>Total Capacity:</span>
                    <span class="stat-value pulse">450 kW</span>
                </div>
                <div class="stat-item">
                    <span>Storage:</span>
                    <span class="stat-value">850 kWh</span>
                </div>
                <div class="stat-item">
                    <span>Efficiency:</span>
                    <span class="stat-value pulse">98.7%</span>
                </div>
                <div class="stat-item">
                    <span>Loss Reduction:</span>
                    <span class="stat-value">15.2%</span>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div style="font-weight: 600; margin-bottom: 15px; font-size: 14px;">Component Legend</div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #1e88e5, #42a5f5);"></div>
                <span>Solar Panels (56.25 kW each)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #2e7d32, #4caf50);"></div>
                <span>Battery Units (283.3 kWh each)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #7b1fa2, #9c27b0);"></div>
                <span>Control Infrastructure</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(135deg, #f57c00, #ff9800);"></div>
                <span>Power Distribution</span>
            </div>
            <div style="margin-top: 20px; font-size: 10px; color: #90a4ae; line-height: 1.4;">
                <strong>Controls:</strong><br>
                Mouse: Orbit view<br>
                Wheel: Zoom in/out<br>
                Auto-rotation enabled
            </div>
        </div>
        
        <div class="controls">
            <button class="control-button" onclick="toggleRotation()">Toggle Rotation</button>
            <button class="control-button" onclick="resetView()">Reset View</button>
            <button class="control-button" onclick="toggleWireframe()">Wireframe</button>
            <button class="control-button" onclick="toggleParticles()">Particles</button>
        </div>
        
        <div class="performance-indicator">
            <div>Performance</div>
            <div class="fps-counter" id="fps">FPS: --</div>
            <div style="margin-top: 5px; font-size: 10px; color: #90a4ae;">
                Objects: <span id="objectCount">--</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let solarPanels = [];
        let batteries = [];
        let powerLines = [];
        let particles = [];
        let particleSystem;
        let autoRotate = true;
        let wireframeMode = false;
        let showParticles = true;
        
        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            // Dynamic sky gradient
            const skyGradient = createSkyGradient();
            scene.background = skyGradient;
            scene.fog = new THREE.Fog(0x87CEEB, 80, 400);
            
            // Camera setup with improved positioning
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(60, 50, 60);
            camera.lookAt(0, 5, 0);
            
            // Enhanced renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Advanced lighting system
            setupAdvancedLighting();
            
            // Enhanced environment
            createEnhancedGround();
            createAdvancedSolarPanels();
            createAdvancedBatteries();
            createAdvancedControlCenter();
            createDynamicPowerLines();
            createAdvancedEnvironment();
            createParticleSystem();
            
            // Enhanced controls
            setupAdvancedControls();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
            
            // Update object count
            updatePerformanceStats();
        }
        
        function createSkyGradient() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#98D8E8');
            gradient.addColorStop(1, '#B0E0E6');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        function setupAdvancedLighting() {
            // Realistic sun
            const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
            sunLight.position.set(100, 150, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            // Enhanced ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // Hemisphere light for realistic sky illumination
            const skyLight = new THREE.HemisphereLight(0x87CEEB, 0x2d4a22, 1.2);
            skyLight.position.set(0, 100, 0);
            scene.add(skyLight);
            
            // Rim lighting
            const rimLight = new THREE.DirectionalLight(0x9bb0ff, 0.8);
            rimLight.position.set(-50, 50, -50);
            scene.add(rimLight);
        }
        
        function createEnhancedGround() {
            // Main ground with noise texture
            const groundGeometry = new THREE.PlaneGeometry(300, 300, 100, 100);
            
            // Add height variation
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 2; i < vertices.length; i += 3) {
                vertices[i] = Math.sin(vertices[i-2] * 0.02) * Math.cos(vertices[i-1] * 0.02) * 2;
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a6741,
                roughness: 0.8,
                metalness: 0.1,
                transparent: true,
                opacity: 0.95
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grass patches with varied colors
            for (let i = 0; i < 50; i++) {
                const patchGeometry = new THREE.CircleGeometry(Math.random() * 4 + 2, 12);
                const hue = 0.25 + Math.random() * 0.15;
                const patchMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.7, 0.3 + Math.random() * 0.3),
                    roughness: 0.9,
                    metalness: 0.0
                });
                const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(
                    (Math.random() - 0.5) * 250,
                    0.1,
                    (Math.random() - 0.5) * 250
                );
                patch.receiveShadow = true;
                scene.add(patch);
            }
        }
        
        function createAdvancedSolarPanels() {
            const positions = [
                [-18, 0, -25], [-6, 0, -25], [6, 0, -25], [18, 0, -25],
                [-12, 0, -12], [0, 0, -12], [12, 0, -12],
                [0, 0, 2]
            ];
            
            positions.forEach((pos, index) => {
                const panel = createAdvancedSolarPanel();
                panel.position.set(pos[0], pos[1] + 3, pos[2]);
                panel.userData = { 
                    id: `SP${index + 1}`, 
                    type: 'solar',
                    efficiency: 0.85 + Math.random() * 0.1,
                    power: 56.25
                };
                solarPanels.push(panel);
                scene.add(panel);
            });
        }
        
        function createAdvancedSolarPanel() {
            const group = new THREE.Group();
            
            // Enhanced panel frame with metallic finish
            const frameGeometry = new THREE.BoxGeometry(10, 0.4, 6);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.7,
                roughness: 0.3
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.castShadow = true;
            frame.receiveShadow = true;
            group.add(frame);
            
            // Realistic solar cells with reflection
            const cellsGeometry = new THREE.BoxGeometry(9.5, 0.42, 5.5);
            const cellsMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a237e,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.95,
                envMapIntensity: 1.5
            });
            const cells = new THREE.Mesh(cellsGeometry, cellsMaterial);
            cells.position.y = 0.01;
            group.add(cells);
            
            // Individual solar cell grid with realistic spacing
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 5; j++) {
                    const cellGeometry = new THREE.PlaneGeometry(1.1, 1);
                    const cellMaterial = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(0.65, 0.8, 0.2 + Math.random() * 0.1),
                        metalness: 0.8,
                        roughness: 0.2,
                        transparent: true,
                        opacity: 0.9
                    });
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.position.set(
                        -4.5 + i * 1.2,
                        0.22,
                        -2.5 + j * 1.1
                    );
                    cell.rotation.x = -Math.PI / 2;
                    group.add(cell);
                }
            }
            
            // Enhanced support structure
            const supportPositions = [[-4, -2], [4, -2], [-4, 2], [4, 2]];
            supportPositions.forEach(pos => {
                const supportGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3);
                const supportMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x7f8c8d,
                    metalness: 0.6,
                    roughness: 0.4
                });
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                support.position.set(pos[0], -1.5, pos[1]);
                support.castShadow = true;
                group.add(support);
            });
            
            // Optimal tilt angle
            group.rotation.x = -Math.PI / 8;
            
            return group;
        }
        
        function createAdvancedBatteries() {
            const positions = [
                [-8, 0, 35], [8, 0, 35], [0, 0, 45]
            ];
            
            positions.forEach((pos, index) => {
                const battery = createAdvancedBattery();
                battery.position.set(pos[0], pos[1], pos[2]);
                battery.userData = { 
                    id: `B${index + 1}`, 
                    type: 'battery',
                    capacity: 283.3,
                    charge: 0.7 + Math.random() * 0.3
                };
                batteries.push(battery);
                scene.add(battery);
            });
        }
        
        function createAdvancedBattery() {
            const group = new THREE.Group();
            
            // Modern battery container with gradient
            const containerGeometry = new THREE.BoxGeometry(5, 4, 8);
            const containerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x27ae60,
                metalness: 0.4,
                roughness: 0.6,
                emissive: 0x0a3d20,
                emissiveIntensity: 0.1
            });
            const container = new THREE.Mesh(containerGeometry, containerMaterial);
            container.position.y = 2;
            container.castShadow = true;
            container.receiveShadow = true;
            group.add(container);
            
            // LED status indicators
            for (let i = 0; i < 3; i++) {
                const ledGeometry = new THREE.SphereGeometry(0.2);
                const ledMaterial = new THREE.MeshStandardMaterial({ 
                    color: i < 2 ? 0x00ff00 : 0xff0000,
                    emissive: i < 2 ? 0x004400 : 0x440000,
                    emissiveIntensity: 0.5
                });
                const led = new THREE.Mesh(ledGeometry, ledMaterial);
                led.position.set(-1.5 + i * 1.5, 3.5, 4.1);
                group.add(led);
            }
            
            // Cooling system
            for (let i = 0; i < 6; i++) {
                const ventGeometry = new THREE.BoxGeometry(4, 0.15, 0.3);
                const ventMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1e8449,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const vent = new THREE.Mesh(ventGeometry, ventMaterial);
                vent.position.set(0, 2 + (i - 2.5) * 0.5, 4.2);
                group.add(vent);
            }
            
            // Industrial base platform
            const baseGeometry = new THREE.BoxGeometry(6, 0.4, 9);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c3e50,
                metalness: 0.7,
                roughness: 0.3
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);
            
            return group;
        }
        
        function createAdvancedControlCenter() {
            const group = new THREE.Group();
            
            // Main control building with modern design
            const buildingGeometry = new THREE.BoxGeometry(12, 6, 8);
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8e44ad,
                metalness: 0.3,
                roughness: 0.7,
                emissive: 0x2d1b3d,
                emissiveIntensity: 0.05
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(35, 3, 0);
            building.castShadow = true;
            building.receiveShadow = true;
            group.add(building);
            
            // Communication array
            const antennaGeometry = new THREE.CylinderGeometry(0.15, 0.15, 8);
            const antennaMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x34495e,
                metalness: 0.8,
                roughness: 0.2
            });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(35, 10, 0);
            antenna.castShadow = true;
            group.add(antenna);
            
            // Satellite dish
            const dishGeometry = new THREE.CylinderGeometry(2, 2, 0.3, 16);
            const dishMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xecf0f1,
                metalness: 0.9,
                roughness: 0.1
            });
            const dish = new THREE.Mesh(dishGeometry, dishMaterial);
            dish.position.set(35, 14, 0);
            dish.rotation.x = -Math.PI / 6;
            group.add(dish);
            
            // Modern windows with glow
            const windowGeometry = new THREE.PlaneGeometry(1.5, 2);
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3498db,
                transparent: true,
                opacity: 0.8,
                emissive: 0x1a5490,
                emissiveIntensity: 0.3
            });
            
            for (let i = 0; i < 4; i++) {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(29, 3.5, -3 + i * 2);
                window.rotation.y = Math.PI / 2;
                group.add(window);
            }
            
            scene.add(group);
        }
        
        function createDynamicPowerLines() {
            powerLines = [];
            
            // Enhanced power line material with glow effect
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff9800,
                emissive: 0x663300,
                emissiveIntensity: 0.3,
                metalness: 0.8,
                roughness: 0.2
            });
            
            // Connect solar panels to batteries with curved lines
            solarPanels.forEach((panel, index) => {
                const batteryIndex = Math.floor(index / 3) % batteries.length;
                if (batteries[batteryIndex]) {
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(panel.position.x, panel.position.y + 2, panel.position.z),
                        new THREE.Vector3(
                            (panel.position.x + batteries[batteryIndex].position.x) / 2,
                            panel.position.y + 8,
                            (panel.position.z + batteries[batteryIndex].position.z) / 2
                        ),
                        new THREE.Vector3(
                            batteries[batteryIndex].position.x,
                            batteries[batteryIndex].position.y + 3,
                            batteries[batteryIndex].position.z
                        )
                    ]);
                    
                    const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
                    const powerLine = new THREE.Mesh(tubeGeometry, lineMaterial);
                    powerLines.push(powerLine);
                    scene.add(powerLine);
                }
            });
            
            // Connect batteries to control center
            batteries.forEach(battery => {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(battery.position.x, battery.position.y + 3, battery.position.z),
                    new THREE.Vector3(
                        (battery.position.x + 35) / 2,
                        battery.position.y + 10,
                        battery.position.z / 2
                    ),
                    new THREE.Vector3(35, 4, 0)
                ]);
                
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
                const powerLine = new THREE.Mesh(tubeGeometry, lineMaterial);
                powerLines.push(powerLine);
                scene.add(powerLine);
            });
        }
        
        function createAdvancedEnvironment() {
            // Realistic trees with detailed geometry
            for (let i = 0; i < 25; i++) {
                const tree = createRealisticTree();
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                
                // Avoid placing trees on equipment
                if (Math.abs(x) < 50 && Math.abs(z) < 60) {
                    continue;
                }
                
                tree.position.set(x, 0, z);
                tree.scale.set(
                    0.8 + Math.random() * 0.6,
                    0.8 + Math.random() * 0.8,
                    0.8 + Math.random() * 0.6
                );
                scene.add(tree);
            }
            
            // Volumetric clouds
            createVolumetricClouds();
            
            // Add distant mountains
            createMountains();
            
            // Add realistic birds
            createBirds();
        }
        
        function createRealisticTree() {
            const group = new THREE.Group();
            
            // Detailed trunk with bark texture
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 12, 8);
            const vertices = trunkGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i] += (Math.random() - 0.5) * 0.3;
                vertices[i + 2] += (Math.random() - 0.5) * 0.3;
            }
            trunkGeometry.attributes.position.needsUpdate = true;
            
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color().setHSL(0.08, 0.6, 0.3),
                roughness: 0.9,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 6;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Layered foliage
            for (let layer = 0; layer < 3; layer++) {
                const leavesGeometry = new THREE.SphereGeometry(
                    5 - layer * 0.8, 
                    8, 
                    6
                );
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(0.3, 0.7, 0.3 + layer * 0.1),
                    roughness: 0.8,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.9
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 14 + layer * 2;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                group.add(leaves);
            }
            
            return group;
        }
        
        function createVolumetricClouds() {
            const cloudGroup = new THREE.Group();
            
            for (let i = 0; i < 15; i++) {
                const cloudParts = [];
                const numParts = 5 + Math.floor(Math.random() * 5);
                
                for (let j = 0; j < numParts; j++) {
                    const cloudGeometry = new THREE.SphereGeometry(
                        4 + Math.random() * 6, 
                        12, 
                        8
                    );
                    const cloudMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.6 + Math.random() * 0.3,
                        roughness: 1.0,
                        metalness: 0.0
                    });
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 15
                    );
                    cloudParts.push(cloudPart);
                }
                
                const cloud = new THREE.Group();
                cloudParts.forEach(part => cloud.add(part));
                
                cloud.position.set(
                    (Math.random() - 0.5) * 500,
                    40 + Math.random() * 30,
                    (Math.random() - 0.5) * 500
                );
                
                cloudGroup.add(cloud);
            }
            
            scene.add(cloudGroup);
        }
        
        function createMountains() {
            const mountainGroup = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                const mountainGeometry = new THREE.ConeGeometry(
                    20 + Math.random() * 30, 
                    30 + Math.random() * 40, 
                    8
                );
                const mountainMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(0.6, 0.3, 0.4 + Math.random() * 0.2),
                    roughness: 0.9,
                    metalness: 0.0
                });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(
                    (Math.random() - 0.5) * 800,
                    15,
                    -300 + Math.random() * 100
                );
                mountain.receiveShadow = true;
                mountainGroup.add(mountain);
            }
            
            scene.add(mountainGroup);
        }
        
        function createBirds() {
            const birdGroup = new THREE.Group();
            
            for (let i = 0; i < 5; i++) {
                const birdGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                const birdMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2c3e50,
                    roughness: 0.8,
                    metalness: 0.0
                });
                const bird = new THREE.Mesh(birdGeometry, birdMaterial);
                bird.position.set(
                    (Math.random() - 0.5) * 200,
                    20 + Math.random() * 30,
                    (Math.random() - 0.5) * 200
                );
                bird.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.5
                    ),
                    phase: Math.random() * Math.PI * 2
                };
                birdGroup.add(bird);
            }
            
            scene.add(birdGroup);
            return birdGroup;
        }
        
        function createParticleSystem() {
            // Energy flow particles
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                
                const color = new THREE.Color();
                color.setHSL(0.15 + Math.random() * 0.1, 0.8, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = Math.random() * 2 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }
        
        function setupAdvancedControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationY = 0;
            let targetRotationX = 0;
            let currentRotationY = 0;
            let currentRotationX = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                autoRotate = false;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                const distance = camera.position.length();
                const newDistance = Math.max(20, Math.min(200, distance * scale));
                camera.position.normalize().multiplyScalar(newDistance);
            });
            
            // Smooth camera interpolation
            function updateCamera() {
                if (!autoRotate) {
                    currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                    currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                    
                    const distance = camera.position.length();
                    camera.position.x = Math.cos(currentRotationY) * Math.cos(currentRotationX) * distance;
                    camera.position.y = Math.sin(currentRotationX) * distance;
                    camera.position.z = Math.sin(currentRotationY) * Math.cos(currentRotationX) * distance;
                    camera.lookAt(0, 5, 0);
                }
            }
            
            camera.updateCamera = updateCamera;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update performance stats
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // Auto rotation with smooth movement
            if (autoRotate) {
                const rotationSpeed = 0.0003;
                camera.position.x = Math.cos(time * rotationSpeed) * 80;
                camera.position.z = Math.sin(time * rotationSpeed) * 80;
                camera.position.y = 50 + Math.sin(time * rotationSpeed * 0.5) * 10;
                camera.lookAt(0, 5, 0);
            } else if (camera.updateCamera) {
                camera.updateCamera();
            }
            
            // Animate solar panel efficiency visualization
            solarPanels.forEach((panel, index) => {
                const efficiency = panel.userData.efficiency;
                const shimmerTime = time * 2 + index;
                
                panel.children.forEach((child, childIndex) => {
                    if (child.material && child.material.emissiveIntensity !== undefined) {
                        child.material.emissiveIntensity = efficiency * 0.1 + Math.sin(shimmerTime) * 0.05;
                    }
                });
            });
            
            // Animate battery charge indicators
            batteries.forEach((battery, index) => {
                const charge = battery.userData.charge;
                const pulseTime = time * 3 + index;
                
                battery.children.forEach(child => {
                    if (child.material && child.material.color.r === 0) { // Green LED
                        child.material.emissiveIntensity = charge * 0.5 + Math.sin(pulseTime) * 0.2;
                    }
                });
            });
            
            // Animate power lines with energy flow
            powerLines.forEach((line, index) => {
                const flowTime = time * 2 + index * 0.5;
                line.material.emissiveIntensity = 0.3 + Math.sin(flowTime) * 0.2;
            });
            
            // Animate particle system
            if (particleSystem && showParticles) {
                const positions = particleSystem.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time + i) * 0.02;
                    
                    // Reset particles that go too high
                    if (positions[i + 1] > 60) {
                        positions[i + 1] = 0;
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.y = time * 0.1;
            }
            
            // Animate birds
            scene.traverse((object) => {
                if (object.userData.velocity) {
                    object.position.add(object.userData.velocity);
                    object.userData.phase += 0.1;
                    object.position.y += Math.sin(object.userData.phase) * 0.1;
                    
                    // Keep birds in bounds
                    if (Math.abs(object.position.x) > 200) object.userData.velocity.x *= -1;
                    if (Math.abs(object.position.z) > 200) object.userData.velocity.z *= -1;
                    if (object.position.y < 15 || object.position.y > 60) object.userData.velocity.y *= -1;
                }
            });
            
            // Dynamic lighting changes
            const sunIntensity = 2.5 + Math.sin(time * 0.1) * 0.3;
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = sunIntensity;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function toggleRotation() {
            autoRotate = !autoRotate;
        }
        
        function resetView() {
            camera.position.set(60, 50, 60);
            camera.lookAt(0, 5, 0);
            autoRotate = true;
        }
        
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            scene.traverse((child) => {
                if (child.material && child.material.wireframe !== undefined) {
                    child.material.wireframe = wireframeMode;
                }
            });
        }
        
        function toggleParticles() {
            showParticles = !showParticles;
            if (particleSystem) {
                particleSystem.visible = showParticles;
            }
        }
        
        function updatePerformanceStats() {
            let objectCount = 0;
            scene.traverse(() => {
                objectCount++;
            });
            document.getElementById('objectCount').textContent = objectCount;
        }
        
        // Handle window resize with performance optimization
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        
        window.addEventListener('resize', onWindowResize, false);
        
        // Performance monitoring
        const stats = {
            begin: function() { this.startTime = performance.now(); },
            end: function() { 
                this.endTime = performance.now();
                this.frameTime = this.endTime - this.startTime;
            }
        };
        
        // Initialize the enhanced scene
        init();
    </script>
</body>
</html>